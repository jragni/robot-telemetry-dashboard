import React from 'react';
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { render, screen, waitFor } from '@/test-utils';
import userEvent from '@testing-library/user-event';
import PilotMode from '@/components/pilot/PilotMode';
import { 
  mockROSLIB, 
  setupRosConnectionMocks, 
  cleanupRosConnectionMocks,
  createMockConnectionContext,
  createMockTopicSubscription
} from '@/test-utils';
import { useConnection } from '@/components/dashboard/ConnectionProvider';
import { usePilotMode } from '@/components/pilot/usePilotMode';

// Mock dependencies
vi.mock('roslib', () => ({ default: mockROSLIB }));
vi.mock('@/components/dashboard/ConnectionProvider', () => ({
  useConnection: vi.fn(),
  default: vi.fn(({ children }: { children: React.ReactNode }) => <div data-testid="connection-provider">{children}</div>)
}));
vi.mock('next-themes', () => ({
  ThemeProvider: vi.fn(({ children }: { children: React.ReactNode }) => <div data-testid="theme-provider">{children}</div>),
  useTheme: vi.fn(() => ({ theme: 'dark', setTheme: vi.fn() }))
}));
vi.mock('@/components/dashboard/CameraProvider', () => ({
  useCamera: vi.fn(() => ({
    imageUrl: 'data:image/png;base64,mock-image',
    isSubscribed: true,
    toggleCameraSubscription: vi.fn(),
  })),
  default: vi.fn(({ children }: { children: React.ReactNode }) => <div data-testid="camera-provider">{children}</div>)
}));
vi.mock('@/components/pilot/usePilotMode', () => ({
  usePilotMode: vi.fn(),
  PilotModeProvider: vi.fn(({ children }: { children: React.ReactNode }) => <div data-testid="pilot-mode-provider">{children}</div>),
}));
// Mock D3 with complete implementation
vi.mock('d3', () => {
  const mockSelection = {
    select: vi.fn().mockReturnThis(),
    selectAll: vi.fn().mockReturnThis(),
    attr: vi.fn().mockReturnThis(),
    append: vi.fn().mockReturnThis(),
    call: vi.fn().mockReturnThis(),
    style: vi.fn().mockReturnThis(),
    text: vi.fn().mockReturnThis(),
    data: vi.fn().mockReturnThis(),
    enter: vi.fn().mockReturnThis(),
    merge: vi.fn().mockReturnThis(),
    exit: vi.fn().mockReturnThis(),
    remove: vi.fn().mockReturnThis(),
    empty: vi.fn(() => false),
  };

  return {
    select: vi.fn(() => mockSelection),
    scaleLinear: vi.fn(() => ({
      domain: vi.fn().mockReturnThis(),
      range: vi.fn().mockReturnThis(),
      ticks: vi.fn(() => [0, 1, 2, 3, 4, 5]),
    })),
    axisBottom: vi.fn(() => ({
      ticks: vi.fn().mockReturnThis(),
    })),
    axisLeft: vi.fn(() => ({
      ticks: vi.fn().mockReturnThis(),
    })),
  };
});

const mockUseConnection = useConnection as vi.MockedFunction<typeof useConnection>;
const mockUsePilotMode = usePilotMode as vi.MockedFunction<typeof usePilotMode>;

describe('PilotMode UI Transparency', () => {
  beforeEach(() => {
    setupRosConnectionMocks();
    mockUseConnection.mockReturnValue(createMockConnectionContext());
    mockUsePilotMode.mockReturnValue({
      isPilotMode: true,
      enterPilotMode: vi.fn(),
      exitPilotMode: vi.fn(),
    });
  });

  afterEach(() => {
    cleanupRosConnectionMocks();
    vi.clearAllMocks();
  });

  describe('Transparent Control Panel', () => {
    it('should render control panel without background cards in desktop mode', () => {
      // Set desktop viewport
      Object.defineProperty(window, 'innerWidth', {
        writable: true,
        configurable: true,
        value: 1024,
      });

      render(<PilotMode />);

      // Control panel should be present
      expect(screen.getByText('Controls')).toBeInTheDocument();
      
      // Should not have card background classes
      const controlSection = screen.getByText('Controls').closest('div');
      expect(controlSection).not.toHaveClass('bg-black/30');
      expect(controlSection).not.toHaveClass('backdrop-blur-sm');
      expect(controlSection).not.toHaveClass('border');
      expect(controlSection).not.toHaveClass('border-gray-400/30');
    });

    it('should render control panel without background cards in mobile mode', () => {
      // Set mobile viewport
      Object.defineProperty(window, 'innerWidth', {
        writable: true,
        configurable: true,
        value: 375,
      });

      render(<PilotMode />);

      // Control panel should be present
      expect(screen.getByText('Controls')).toBeInTheDocument();
      
      // Should not have background styling in mobile layout
      const controlSection = screen.getByText('Controls').closest('div');
      expect(controlSection).not.toHaveClass('bg-black/40');
      expect(controlSection).not.toHaveClass('backdrop-blur-sm');
    });

    it('should maintain all control buttons functionality with transparency', async () => {
      const user = userEvent.setup();
      
      render(<PilotMode />);

      // All directional buttons should be present and clickable
      const forwardButton = screen.getByRole('button', { name: /arrow.*up/i });
      const backwardButton = screen.getByRole('button', { name: /arrow.*down/i });
      const leftButton = screen.getByRole('button', { name: /arrow.*left/i });
      const rightButton = screen.getByRole('button', { name: /arrow.*right/i });
      const stopButton = screen.getByRole('button', { name: /square/i });

      expect(forwardButton).toBeInTheDocument();
      expect(backwardButton).toBeInTheDocument();
      expect(leftButton).toBeInTheDocument();
      expect(rightButton).toBeInTheDocument();
      expect(stopButton).toBeInTheDocument();

      // Test button interactions
      await user.click(forwardButton);
      await user.click(stopButton);
      
      // Buttons should remain functional
      expect(forwardButton).toBeEnabled();
      expect(stopButton).toBeEnabled();
    });

    it('should maintain velocity sliders functionality with transparency', async () => {
      const user = userEvent.setup();
      
      render(<PilotMode />);

      // Velocity sliders should be present and functional
      const sliders = screen.getAllByRole('slider');
      expect(sliders).toHaveLength(2); // Linear and angular velocity

      // Test slider interaction
      await user.click(sliders[0]);
      
      expect(sliders[0]).toBeEnabled();
    });

    it('should apply text shadows for better visibility over camera background', () => {
      render(<PilotMode />);

      const controlsTitle = screen.getByText('Controls');
      const linearLabel = screen.getByText('Linear:');
      const angularLabel = screen.getByText('Angular:');

      // Check for text shadow styling for visibility
      expect(controlsTitle).toHaveStyle('text-shadow: 0 1px 3px rgba(0,0,0,0.8)');
      expect(linearLabel).toHaveStyle('text-shadow: 0 1px 3px rgba(0,0,0,0.8)');
      expect(angularLabel).toHaveStyle('text-shadow: 0 1px 3px rgba(0,0,0,0.8)');
    });
  });

  describe('Transparent LiDAR Visualization', () => {
    it('should render LiDAR visualization without background cards in desktop mode', () => {
      Object.defineProperty(window, 'innerWidth', {
        writable: true,
        configurable: true,
        value: 1024,
      });

      render(<PilotMode />);

      expect(screen.getByText('LiDAR')).toBeInTheDocument();
      
      // Should not have card background classes
      const lidarSection = screen.getByText('LiDAR').closest('div');
      expect(lidarSection).not.toHaveClass('bg-black/30');
      expect(lidarSection).not.toHaveClass('backdrop-blur-sm');
      expect(lidarSection).not.toHaveClass('border');
      expect(lidarSection).not.toHaveClass('border-gray-400/30');
    });

    it('should render LiDAR visualization without background cards in mobile mode', () => {
      Object.defineProperty(window, 'innerWidth', {
        writable: true,
        configurable: true,
        value: 375,
      });

      render(<PilotMode />);

      expect(screen.getByText('LiDAR')).toBeInTheDocument();
      
      // Should not have background styling in mobile layout
      const lidarContainer = screen.getByText('LiDAR').closest('div');
      expect(lidarContainer).not.toHaveClass('bg-black/20');
      expect(lidarContainer).not.toHaveClass('border');
      expect(lidarContainer).not.toHaveClass('border-gray-400/30');
    });

    it('should maintain LiDAR visualization functionality with transparency', async () => {
      const mockTopic = createMockTopicSubscription('sensor_msgs/LaserScan', '/scan');
      mockROSLIB.Topic.mockImplementation(() => mockTopic);

      render(<PilotMode />);

      // LiDAR should still be functional
      expect(screen.getByText('LiDAR')).toBeInTheDocument();
      
      // SVG should be present for visualization
      const svgElement = document.querySelector('svg');
      expect(svgElement).toBeInTheDocument();
    });

    it('should maintain topic selector functionality with transparency', async () => {
      const user = userEvent.setup();
      
      render(<PilotMode />);

      // Topic selector should be present and functional
      const topicSelect = screen.getByRole('combobox');
      expect(topicSelect).toBeInTheDocument();
      
      await user.click(topicSelect);
      // Should open dropdown without issues
    });

    it('should apply text shadows to LiDAR labels for better visibility', () => {
      render(<PilotMode />);

      const lidarTitle = screen.getByText('LiDAR');
      
      // Check for text shadow styling for visibility over camera
      expect(lidarTitle).toHaveStyle('text-shadow: 0 1px 3px rgba(0,0,0,0.8)');
    });
  });

  describe('Text Readability', () => {
    it('should have high contrast text for readability over camera', () => {
      render(<PilotMode />);

      const controlsTitle = screen.getByText('Controls');
      const lidarTitle = screen.getByText('LiDAR');
      
      // Text should be white for contrast against dark/varied camera backgrounds
      expect(controlsTitle).toHaveClass('text-white');
      expect(lidarTitle).toHaveClass('text-white');
    });

    it('should have text outlines for better visibility', () => {
      render(<PilotMode />);

      const statusElements = [
        screen.getByText('Controls'),
        screen.getByText('LiDAR'),
        screen.getByText('Linear:'),
        screen.getByText('Angular:')
      ];

      statusElements.forEach(element => {
        // Should have text stroke or shadow for visibility
        const styles = window.getComputedStyle(element);
        expect(
          styles.textShadow || styles.webkitTextStroke
        ).toBeTruthy();
      });
    });

    it('should maintain button visibility with proper contrast', async () => {
      render(<PilotMode />);

      const buttons = screen.getAllByRole('button');
      
      buttons.forEach(button => {
        // Buttons should maintain their contrast styling
        expect(button).toBeVisible();
      });
    });
  });

  describe('Layout Preservation', () => {
    it('should maintain proper spacing without background containers', () => {
      render(<PilotMode />);

      // Control panel should maintain its positioning
      const controlsTitle = screen.getByText('Controls');
      expect(controlsTitle).toBeInTheDocument();
      
      // LiDAR should maintain its positioning
      const lidarTitle = screen.getByText('LiDAR');
      expect(lidarTitle).toBeInTheDocument();
    });

    it('should maintain responsive grid layout without backgrounds', () => {
      render(<PilotMode />);

      // Movement grid should still work
      const controlGrid = document.querySelector('.grid.grid-cols-3');
      expect(controlGrid).toBeInTheDocument();
    });

    it('should preserve component hierarchy and accessibility', () => {
      render(<PilotMode />);

      // All interactive elements should remain accessible
      const interactiveElements = [
        ...screen.getAllByRole('button'),
        ...screen.getAllByRole('slider'),
        ...screen.getAllByRole('combobox')
      ];

      interactiveElements.forEach(element => {
        expect(element).toBeInTheDocument();
        expect(element).toBeVisible();
      });
    });
  });

  describe('Camera Background Integration', () => {
    it('should allow camera background to show through transparent controls', () => {
      render(<PilotMode />);

      // Verify fullscreen camera is present
      const cameraElement = document.querySelector('[data-testid="pilot-camera"]') || 
                           document.querySelector('video') ||
                           document.querySelector('canvas');
      
      // Camera should be behind controls
      expect(screen.getByText('Controls')).toBeInTheDocument();
    });

    it('should maintain proper z-index layering', () => {
      render(<PilotMode />);

      // Exit button should be on top
      const exitButton = screen.getByRole('button', { name: /exit|✕/i });
      expect(exitButton).toHaveClass('z-50');
      
      // Pilot mode container should be above everything else
      const pilotContainer = document.querySelector('.fixed.inset-0.z-50');
      expect(pilotContainer).toBeInTheDocument();
    });

    it('should not obstruct camera view with backgrounds', () => {
      render(<PilotMode />);

      // Controls should not have opaque backgrounds that block camera
      const controlContainers = document.querySelectorAll('[class*="bg-black"]');
      
      controlContainers.forEach(container => {
        const classes = container.className;
        // Should not have solid backgrounds, only semi-transparent ones for specific UI elements
        expect(classes).not.toMatch(/bg-black\/[789]\d|bg-black$/);
      });
    });
  });

  describe('Performance with Transparency', () => {
    it('should maintain smooth rendering without background blur effects', async () => {
      const user = userEvent.setup();
      
      render(<PilotMode />);

      // Rapid interactions should not cause performance issues
      const forwardButton = screen.getByRole('button', { name: /arrow.*up/i });
      
      for (let i = 0; i < 10; i++) {
        await user.click(forwardButton);
      }

      // Component should remain responsive
      expect(forwardButton).toBeInTheDocument();
    });

    it('should not have backdrop-blur effects that impact performance', () => {
      render(<PilotMode />);

      // Check that backdrop-blur is removed from control areas
      const elementsWithBlur = document.querySelectorAll('[class*="backdrop-blur"]');
      
      // Should only have backdrop-blur on essential UI elements like status bar and exit button
      elementsWithBlur.forEach(element => {
        const classes = element.className;
        expect(classes).toMatch(/(top-.*status|exit.*button)/i);
      });
    });
  });

  describe('Exit Functionality', () => {
    it('should maintain exit button functionality with transparent UI', async () => {
      const mockExitPilotMode = vi.fn();
      mockUsePilotMode.mockReturnValue({
        isPilotMode: true,
        enterPilotMode: vi.fn(),
        exitPilotMode: mockExitPilotMode,
      });

      const user = userEvent.setup();
      render(<PilotMode />);

      const exitButton = screen.getByRole('button', { name: /exit|✕/i });
      await user.click(exitButton);

      expect(mockExitPilotMode).toHaveBeenCalled();
    });
  });
});